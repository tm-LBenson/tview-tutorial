<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Step-by-Step Bank App in Go With tview</title>
  <link rel="stylesheet" href="styles.css">
  <script src="tooltips.js" defer></script>
</head>
<body>
<main>
  <header>
    <h1>Step-by-Step Bank App in Go With tview</h1>
    <p class="tagline">
      Build a small terminal bank app in Go, one version of <code>main.go</code> at a time.
      Each step runs on its own, and the explanations live in hover tooltips.
    </p>
  </header>

  <!-- STEP 0: SETUP -->
  <section>
    <h2>Step 0 – Project setup</h2>
    <p>
      In this tutorial, each step is a complete version of <code>main.go</code>.
      You will:
    </p>
    <ul>
      <li>Create a folder and Go module.</li>
      <li>At each step, replace <code>main.go</code> with the new version.</li>
      <li>Run it and see what changed.</li>
    </ul>

    <p>Create a folder and initialize a module:</p>
    <pre class="code-block"><code>mkdir tview-bank
cd tview-bank
go mod init github.com/yourname/tview-bank</code></pre>

    <p>Install the UI libraries:</p>
    <pre class="code-block"><code>go get github.com/rivo/tview
go get github.com/gdamore/tcell/v2</code></pre>

    <p>Now create an empty <code>main.go</code>. We’ll start filling it in at Step 1.</p>
  </section>

  <!-- STEP 1: HELLO TVIEW -->
  <section>
    <h2>Step 1 – Proof of life: Hello tview</h2>
    <p>
      First we just want a tview app that runs and shows a simple message.
      Replace the contents of <code>main.go</code> with this:
    </p>

    <pre class="code-block annotated"><code>
<span class="code-line" data-tooltip="Every executable Go program starts with package main.">package main</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="We only import tview for now, nothing else.">import "github.com/rivo/tview"</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="main is the entry point that Go will run.">func main() {</span>
<span class="code-line" data-tooltip="NewApplication creates the core tview event loop and screen.">    app := tview.NewApplication()</span>
<span class="code-line" data-tooltip="NewTextView is a simple text widget that can show a string.">    text := tview.NewTextView().SetText("Hello, Bank App!")</span>
<span class="code-line" data-tooltip="SetRoot(text, true) tells tview to use the TextView as the full screen.">    app.SetRoot(text, true)</span>
<span class="code-line" data-tooltip="Run starts the UI loop and blocks until you quit or Stop is called.">    if err := app.Run(); err != nil {</span>
<span class="code-line">        panic(err)</span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
</code></pre>

    <p>Run it:</p>
    <pre class="code-block"><code>go run main.go</code></pre>

    <p>You should see “Hello, Bank App!” in the terminal. Press Ctrl+C to abort if needed.</p>
  </section>

  <!-- STEP 2: HARD-CODED BALANCE -->
  <section>
    <h2>Step 2 – Show a hard-coded balance</h2>
    <p>
      Now we introduce the idea of an account balance, but keep it hard-coded in memory.
      We also add a tiny bit of layout: a header and a main area.
    </p>

    <p>Replace <code>main.go</code> with this version and run it again:</p>

    <pre class="code-block annotated"><code>
<span class="code-line">package main</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="fmt is used only to format the balance string here.">import (</span>
<span class="code-line">    "fmt"</span>
<span class="code-line">    "github.com/gdamore/tcell/v2"</span>
<span class="code-line">    "github.com/rivo/tview"</span>
<span class="code-line">)</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="Account represents a single bank account with a balance.">type Account struct {</span>
<span class="code-line">    BalanceCents int64</span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line">func main() {</span>
<span class="code-line" data-tooltip="We create an Account with a hard-coded starting balance.">    account := &Account{BalanceCents: 12345}</span>
<span class="code-line" data-tooltip="Text showing the current balance; 12345 cents is 123.45 dollars.">    balanceText := fmt.Sprintf("Current balance: $%.2f", float64(account.BalanceCents)/100)</span>
<span class="code-line"></span>
<span class="code-line">    app := tview.NewApplication()</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="Header bar at the top.">    header := tview.NewTextView().</span>
<span class="code-line">        SetText("Simple Bank").</span>
<span class="code-line">        SetTextAlign(tview.AlignCenter).</span>
<span class="code-line">        SetTextColor(tcell.ColorWhite)</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="Main TextView for the balance.">    balanceView := tview.NewTextView().</span>
<span class="code-line">        SetText(balanceText).</span>
<span class="code-line">        SetTextAlign(tview.AlignCenter)</span>
<span class="code-line"></span>
<span class="code-line" data-tooltip="Flex layout lets us stack widgets vertically (rows).">    root := tview.NewFlex().</span>
<span class="code-line">        SetDirection(tview.FlexRow).</span>
<span class="code-line">        AddItem(header, 1, 0, false).</span>
<span class="code-line">        AddItem(balanceView, 0, 1, true)</span>
<span class="code-line"></span>
<span class="code-line">    app.SetRoot(root, true)</span>
<span class="code-line">    if err := app.Run(); err != nil {</span>
<span class="code-line">        panic(err)</span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
</code></pre>

    <p>
      You now have a basic layout and a simple account type. Still no file storage, no menu,
      but you have a starting point that looks more like an app.
    </p>
  </section>

  <!-- STEP 3: FILE STORAGE ACCOUNT -->
  <section>
    <h2>Step 3 – Load and save the balance from a file</h2>
    <p>
      Next we want the account to remember its balance between runs.
      We will:
    </p>
    <ul>
      <li>Read <code>account.txt</code> when the app starts.</li>
      <li>Write the balance back to <code>account.txt</code> on exit.</li>
    </ul>

    <p>Replace <code>main.go</code> with this version and run it. You can run it multiple times and see the same balance:</p>

    <pre class="code-block"><code>package main

import (
  "fmt"
  "os"
  "strconv"
  "strings"

  "github.com/gdamore/tcell/v2"
  "github.com/rivo/tview"
)

const accountFile = "account.txt"

type Account struct {
  BalanceCents int64
}

func loadAccount(path string) (*Account, error) {
  data, err := os.ReadFile(path)
  if err != nil {
    if os.IsNotExist(err) {
      return &Account{BalanceCents: 0}, nil
    }
    return nil, err
  }

  s := strings.TrimSpace(string(data))
  if s == "" {
    return &Account{BalanceCents: 0}, nil
  }

  value, err := strconv.ParseInt(s, 10, 64)
  if err != nil {
    return &Account{BalanceCents: 0}, nil
  }

  return &Account{BalanceCents: value}, nil
}

func saveAccount(path string, a *Account) error {
  s := fmt.Sprintf("%d\n", a.BalanceCents)
  return os.WriteFile(path, []byte(s), 0644)
}

func main() {
  account, err := loadAccount(accountFile)
  if err != nil {
    fmt.Println("Error loading account:", err)
    return
  }

  balanceText := fmt.Sprintf("Current balance: $%.2f", float64(account.BalanceCents)/100)

  app := tview.NewApplication()

  header := tview.NewTextView().
    SetText("Bank (file-backed)").
    SetTextAlign(tview.AlignCenter).
    SetTextColor(tcell.ColorWhite)

  balanceView := tview.NewTextView().
    SetText(balanceText).
    SetTextAlign(tview.AlignCenter)

  root := tview.NewFlex().
    SetDirection(tview.FlexRow).
    AddItem(header, 1, 0, false).
    AddItem(balanceView, 0, 1, true)

  app.SetRoot(root, true)

  app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
    if event.Key() == tcell.KeyRune && event.Rune() == 'q' {
      saveAccount(accountFile, account)
      app.Stop()
      return nil
    }
    return event
  })

  if err := app.Run(); err != nil {
    fmt.Println("Error running UI:", err)
  }
}</code></pre>

    <p>
      Now the account is persistent. Press <code>q</code> to quit so it saves.
      Right now you cannot change the balance, but the file wiring is in place.
    </p>
  </section>

  <!-- STEP 4: MENU + SCREENS -->
  <section>
    <h2>Step 4 – Menu and screens (View, Deposit, Withdraw)</h2>
    <p>
      This is the main tview step:
    </p>
    <ul>
      <li>A left-hand menu using <code>tview.List</code>.</li>
      <li>A right-hand <code>tview.Pages</code> area with:
        <ul>
          <li>A balance screen.</li>
          <li>A deposit form.</li>
          <li>A withdraw form.</li>
        </ul>
      </li>
      <li>A status bar at the bottom for messages.</li>
    </ul>

    <p>
      In this step the deposit and withdraw handlers will change the balance,
      but we will ignore overdraft logic for now. The background will stay the same color.
    </p>

    <p>Replace <code>main.go</code> with this version and test deposits and withdrawals:</p>

    <pre class="code-block"><code>package main

import (
  "fmt"
  "math"
  "os"
  "strconv"
  "strings"

  "github.com/gdamore/tcell/v2"
  "github.com/rivo/tview"
)

const accountFile = "account.txt"

type Account struct {
  BalanceCents int64
}

type BankUI struct {
  app          *tview.Application
  account      *Account
  balanceView  *tview.TextView
  statusBar    *tview.TextView
  menu         *tview.List
  pages        *tview.Pages
  depositForm  *tview.Form
  withdrawForm *tview.Form
}

func loadAccount(path string) (*Account, error) {
  data, err := os.ReadFile(path)
  if err != nil {
    if os.IsNotExist(err) {
      return &Account{BalanceCents: 0}, nil
    }
    return nil, err
  }

  s := strings.TrimSpace(string(data))
  if s == "" {
    return &Account{BalanceCents: 0}, nil
  }

  value, err := strconv.ParseInt(s, 10, 64)
  if err != nil {
    return &Account{BalanceCents: 0}, nil
  }

  return &Account{BalanceCents: value}, nil
}

func saveAccount(path string, a *Account) error {
  s := fmt.Sprintf("%d\n", a.BalanceCents)
  return os.WriteFile(path, []byte(s), 0644)
}

func formatCents(cents int64) string {
  sign := ""
  if cents &lt; 0 {
    sign = "-"
    cents = -cents
  }

  dollars := cents / 100
  remainder := cents % 100

  return fmt.Sprintf("%s%d.%02d", sign, dollars, remainder)
}

func parseAmountToCents(input string) (int64, error) {
  input = strings.TrimSpace(input)
  if input == "" {
    return 0, fmt.Errorf("empty amount")
  }

  f, err := strconv.ParseFloat(input, 64)
  if err != nil {
    return 0, err
  }

  cents := int64(math.Round(f * 100))
  if cents &lt;= 0 {
    return 0, fmt.Errorf("amount must be positive")
  }

  return cents, nil
}

func newBankUI(account *Account) *BankUI {
  ui := &BankUI{
    app:     tview.NewApplication(),
    account: account,
  }

  ui.balanceView = tview.NewTextView().
    SetTextAlign(tview.AlignCenter)

  ui.statusBar = tview.NewTextView().
    SetText("Ready").
    SetTextColor(tcell.ColorLightGrey)

  ui.menu = tview.NewList().
    ShowSecondaryText(false)

  ui.pages = tview.NewPages()

  ui.depositForm = tview.NewForm()
  ui.withdrawForm = tview.NewForm()

  ui.initPages()
  ui.initMenu()
  ui.updateBalanceView()

  header := tview.NewTextView().
    SetText("Bank Menu - press q to quit").
    SetTextAlign(tview.AlignCenter).
    SetTextColor(tcell.ColorWhite)

  mainArea := tview.NewFlex().
    SetDirection(tview.FlexColumn).
    AddItem(ui.menu, 24, 0, true).
    AddItem(ui.pages, 0, 1, false)

  root := tview.NewFlex().
    SetDirection(tview.FlexRow).
    AddItem(header, 1, 0, false).
    AddItem(mainArea, 0, 1, true).
    AddItem(ui.statusBar, 1, 0, false)

  ui.app.SetRoot(root, true).
    SetFocus(ui.menu)

  ui.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {
    if event.Key() == tcell.KeyRune && event.Rune() == 'q' {
      saveAccount(accountFile, ui.account)
      ui.app.Stop()
      return nil
    }
    return event
  })

  return ui
}

func (ui *BankUI) initPages() {
  balancePage := tview.NewFlex().
    SetDirection(tview.FlexRow).
    AddItem(ui.balanceView, 0, 1, false)

  ui.pages.AddPage("balance", balancePage, true, true)

  ui.depositForm.
    AddInputField("Amount", "", 20, nil, nil).
    AddButton("Submit", func() {
      field := ui.depositForm.GetFormItem(0).(*tview.InputField)
      amountText := field.GetText()
      ui.handleDeposit(amountText)
    }).
    AddButton("Cancel", func() {
      ui.pages.SwitchToPage("balance")
      ui.app.SetFocus(ui.menu)
    })

  ui.pages.AddPage("deposit", ui.depositForm, true, false)

  ui.withdrawForm.
    AddInputField("Amount", "", 20, nil, nil).
    AddButton("Submit", func() {
      field := ui.withdrawForm.GetFormItem(0).(*tview.InputField)
      amountText := field.GetText()
      ui.handleWithdraw(amountText)
    }).
    AddButton("Cancel", func() {
      ui.pages.SwitchToPage("balance")
      ui.app.SetFocus(ui.menu)
    })

  ui.pages.AddPage("withdraw", ui.withdrawForm, true, false)
}

func (ui *BankUI) initMenu() {
  ui.menu.AddItem("View balance", "", 'v', func() {
    ui.pages.SwitchToPage("balance")
    ui.app.SetFocus(ui.menu)
  })

  ui.menu.AddItem("Deposit", "", 'd', func() {
    ui.depositForm.GetFormItem(0).(*tview.InputField).SetText("")
    ui.pages.SwitchToPage("deposit")
    ui.app.SetFocus(ui.depositForm)
  })

  ui.menu.AddItem("Withdraw", "", 'w', func() {
    ui.withdrawForm.GetFormItem(0).(*tview.InputField).SetText("")
    ui.pages.SwitchToPage("withdraw")
    ui.app.SetFocus(ui.withdrawForm)
  })

  ui.menu.AddItem("Exit", "", 'x', func() {
    saveAccount(accountFile, ui.account)
    ui.app.Stop()
  })
}

func (ui *BankUI) updateBalanceView() {
  text := "Current balance: $" + formatCents(ui.account.BalanceCents)
  ui.balanceView.SetText(text)
}

func (ui *BankUI) setStatus(msg string) {
  ui.statusBar.SetText(msg)
}

func (ui *BankUI) handleDeposit(amountText string) {
  cents, err := parseAmountToCents(amountText)
  if err != nil {
    ui.setStatus("Invalid deposit amount")
    return
  }

  ui.account.BalanceCents += cents

  saveAccount(accountFile, ui.account)
  ui.updateBalanceView()

  ui.setStatus("Deposited $" + formatCents(cents))
  ui.pages.SwitchToPage("balance")
  ui.app.SetFocus(ui.menu)
}

func (ui *BankUI) handleWithdraw(amountText string) {
  cents, err := parseAmountToCents(amountText)
  if err != nil {
    ui.setStatus("Invalid withdraw amount")
    return
  }

  ui.account.BalanceCents -= cents

  saveAccount(accountFile, ui.account)
  ui.updateBalanceView()

  ui.setStatus("Withdrew $" + formatCents(cents))
  ui.pages.SwitchToPage("balance")
  ui.app.SetFocus(ui.menu)
}

func (ui *BankUI) Run() error {
  return ui.app.Run()
}

func main() {
  account, err := loadAccount(accountFile)
  if err != nil {
    fmt.Println("Error loading account:", err)
    return
  }

  ui := newBankUI(account)
  if err := ui.Run(); err != nil {
    fmt.Println("Error running UI:", err)
  }
}</code></pre>

    <p>
      At this point you can:
    </p>
    <ul>
      <li>View the balance.</li>
      <li>Deposit money.</li>
      <li>Withdraw money (no overdraft logic yet).</li>
      <li>Quit (by pressing <code>q</code> or selecting Exit) and see the balance saved to <code>account.txt</code>.</li>
    </ul>
  </section>

  <!-- STEP 5: OVERDRAFT + RED -->
  <section>
    <h2>Step 5 – Overdraft fee and red background</h2>
    <p>
      Final step: add an overdraft fee and a red theme when the account is negative.
      We will:
    </p>
    <ul>
      <li>Add an <code>overdraftFeeCents</code> constant.</li>
      <li>Change the withdraw logic to apply the fee if the balance crosses below zero.</li>
      <li>Add <code>updateTheme</code> to switch colors.</li>
    </ul>

    <p>
      Replace <code>main.go</code> one more time with the final complete program (this is the same code I gave you earlier as the final version):
    </p>

    <pre class="code-block"><code>/* use the final main.go from the previous answer or your current version here */</code></pre>

    <p>
      Now you have:
    </p>
    <ul>
      <li>A runnable tview app built in steps.</li>
      <li>Persistent file-backed balance.</li>
      <li>Deposit and withdraw flows.</li>
      <li>Overdraft fee and red UI theme for negative balances.</li>
    </ul>
  </section>

  <section>
    <h2>How to extend this for teaching</h2>
    <p>
      If you share this with students, you can:
    </p>
    <ul>
      <li>Ask them to implement Step 2 or Step 3 themselves, using only the previous step as a hint.</li>
      <li>Remove the final complete main.go and make that their “final exercise.”</li>
      <li>Add extra hover tooltips to lines you know will be confusing.</li>
    </ul>
  </section>
</main>
</body>
</html>
